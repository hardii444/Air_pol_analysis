# -*- coding: utf-8 -*-
"""hotspot_location.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X7E6ZVBAv8yL86exKsGar4MgpLYkyodG
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# %matplotlib inline
plt.rcParams['figure.figsize'] = (10, 7)

# Warnings
import warnings
warnings.filterwarnings('ignore')

import os

data=pd.read_csv('/content/data.csv',encoding="ISO-8859-1")
data.fillna(0, inplace=True)
data

def calculate_si(so2):
    si=0
    if (so2<=40):
     si= so2*(50/40)
    if (so2>40 and so2<=80):
     si= 50+(so2-40)*(50/40)
    if (so2>80 and so2<=380):
     si= 100+(so2-80)*(100/300)
    if (so2>380 and so2<=800):
     si= 200+(so2-380)*(100/800)
    if (so2>800 and so2<=1600):
     si= 300+(so2-800)*(100/800)
    if (so2>1600):
     si= 400+(so2-1600)*(100/800)
    return si
data['si']=data['so2'].apply(calculate_si)
df= data[['so2','si']]
df.head()

def calculate_ni(no2):
    ni=0
    if(no2<=40):
     ni= no2*50/40
    elif(no2>40 and no2<=80):
     ni= 50+(no2-14)*(50/40)
    elif(no2>80 and no2<=180):
     ni= 100+(no2-80)*(100/100)
    elif(no2>180 and no2<=280):
     ni= 200+(no2-180)*(100/100)
    elif(no2>280 and no2<=400):
     ni= 300+(no2-280)*(100/120)
    else:
     ni= 400+(no2-400)*(100/120)
    return ni
data['ni']=data['no2'].apply(calculate_ni)
df= data[['no2','ni']]
df.head()

def calculate_(rspm):
    rpi=0
    if(rpi<=30):
     rpi=rpi*50/30
    elif(rpi>30 and rpi<=60):
     rpi=50+(rpi-30)*50/30
    elif(rpi>60 and rpi<=90):
     rpi=100+(rpi-60)*100/30
    elif(rpi>90 and rpi<=120):
     rpi=200+(rpi-90)*100/30
    elif(rpi>120 and rpi<=250):
     rpi=300+(rpi-120)*(100/130)
    else:
     rpi=400+(rpi-250)*(100/130)
    return rpi
data['rpi']=data['rspm'].apply(calculate_si)
df= data[['rspm','rpi']]
df.tail()

def calculate_spi(spm):
    spi=0
    if(spm<=50):
     spi=spm
    if(spm<50 and spm<=100):
     spi=spm
    elif(spm>100 and spm<=250):
     spi= 100+(spm-100)*(100/150)
    elif(spm>250 and spm<=350):
     spi=200+(spm-250)
    elif(spm>350 and spm<=450):
     spi=300+(spm-350)*(100/80)
    else:
     spi=400+(spm-430)*(100/80)
    return spi
data['spi']=data['spm'].apply(calculate_spi)
df= data[['spm','spi']]
df.tail()

def calculate_aqi(si,ni,spi,rpi):
    aqi=0
    if(si>=ni and si>=spi and si>=rpi):
     aqi=si
    if(spi>=si and spi>=ni and spi>=rpi):
     aqi=spi
    if(ni>=si and ni>=spi and ni>=rpi):
     aqi=ni
    if(rpi>=si and rpi>=ni and rpi>=spi):
     aqi=rpi
    return aqi
data['AQI']=data.apply(lambda x:calculate_aqi(x['si'],x['ni'],x['spi'],x['rpi']),axis=1)
df= data[['sampling_date','state','si','ni','rpi','spi','AQI']]
df.head()

df.state.unique()

state=pd.read_csv("/content/newlonglat.csv")
state.head()

dff=pd.merge(state.set_index("state"),df.set_index("state"), right_index=True, left_index=True).reset_index()
dff.head()

data

# Replace '0' values in the 'date' column with NaT (Not a Time)
data['date'] = pd.to_datetime(data['date'], format='%Y-%m-%d', errors='coerce')

# Original code
data['year'] = data['date'].dt.year # year
data['year'] = data['year'].fillna(0.0).astype(int)
data = data[(data['year']>0)]

df = data[['AQI','year']].groupby(["year"]).median().reset_index().sort_values(by='year',ascending=False)
f,ax=plt.subplots(figsize=(15,10))
import seaborn as sns
import matplotlib.pyplot as plt
sns.pointplot(x='year', y='AQI', data=df)

import itertools
import dateutil
import statsmodels.api as sm
import matplotlib.dates as mdates

df=data[['AQI','date']]
df["date"] = pd.to_datetime(df['date'])
df.head()

df.isna().sum()

# Calculating the monthly mean for the data

mdf=df.set_index('date').resample('M')["AQI"].mean()
mdf.head()

# Removing months with NaN values

mdata=mdf.reset_index(level=0, inplace=False)
mdata = mdata[np.isfinite(mdata['AQI'])]
mdata=mdata[mdata.date != '1970-01-31']
mdata = mdata.reset_index(drop=True)
mdata.head()

meanAQI = mdata.to_csv('meanAQI.csv',index=False)

# Calculating the weekly mean for the data

weekly=df.set_index('date').resample('W')["AQI"].mean()
weekly.head()

# Removing weeks with NaN values

wdata=weekly.reset_index(level=0, inplace=False)
wdata = wdata[np.isfinite(wdata['AQI'])]
wdata=wdata[wdata.date != '1970-01-04']
wdata = wdata.reset_index(drop=True)
wdata.head()

mdf=mdata.set_index('date')
mdf.sort_values(by='date',ascending=False)
mdf.plot(figsize=(20,10))
plt.show()
y=mdf.AQI

wdf=wdata.set_index('date')
wdf.sort_values(by='date',ascending=False)
wdf.plot(figsize=(20, 10))
plt.show()
y=wdf.AQI

!pip install ipywidgets

import matplotlib.pyplot as plt
import seaborn as sns
import ipywidgets as widgets
from IPython.display import display

def plot_aqi_trend(state=None):
    # Filter data for the selected state if provided
    filtered_data = data
    if state:
        filtered_data = filtered_data[filtered_data['state'] == state]

    # Group data by year and calculate the average AQI for each year
    aqi_trend = filtered_data.groupby('year')['AQI'].mean().reset_index()

    # Plot the AQI trend over time
    plt.figure(figsize=(4, 2))
    sns.lineplot(data=aqi_trend, x='year', y='AQI', marker='o')
    plt.title(f'AQI Trend Over Time ({state if state else "All States"})')
    plt.xlabel('Year')
    plt.ylabel('Average AQI')
    plt.grid(True)
    plt.show()

# Create a dropdown widget for state selection
state_dropdown = widgets.Dropdown(
    options=['All States'] + list(data['state'].unique()),  # Add "All States" and unique states from your dataset
    value='All States',
    description='Select State:',
)

# Define a function to update the plot when the dropdown selection changes
def update_plot(change):
    selected_state = change['new']
    if selected_state == 'All States':
        plot_aqi_trend()  # Plot for all states
    else:
        plot_aqi_trend(selected_state)  # Plot for the selected state

# Attach the function to the dropdown's change event
state_dropdown.observe(update_plot, names='value')

# Display the dropdown widget
display(state_dropdown)

longitudes = state["long"].tolist()
latitudes = state["lat"].tolist()

stlist=state['state'].tolist()
stlist = [x.strip(' ') for x in stlist]
data['state'] = [x.strip(' ') for x in data['state']]

yrst = pd.DataFrame(0, index=np.arange(29), columns=stlist)

for yr in range(1987,2016):
    for st in range(len(stlist)):
        ydata =data[data["year"]==yr]
        ysdata = ydata[ydata["state"]==stlist[st]]
        ysdata['AQI'] = ysdata['AQI'].fillna(0.0).astype(int)
        ysdata = ysdata[(ysdata['AQI']>0)]
        if ysdata.empty:
            yrst.at[yr-1987,stlist[st]] = 0
        else:
            yrst.at[yr-1987,stlist[st]] = np.median(ysdata['AQI'])

yrst

import folium

import folium
from IPython.display import display
import pandas as pd
import numpy as np

# Assuming 'yrst' DataFrame is already prepared as in your code
# This code snippet will create a map that shows AQI hotspots based on the year selected.

def display_hotspot_map(year):
    """
    Function to display the AQI hotspots on a map based on the selected year.
    The map will display circles with color coding based on AQI values.
    """
    # Create a Folium map centered around India or any region of interest
    m = folium.Map(location=[20.5937, 78.9629], zoom_start=5)  # Coordinates for India

    # Check if the selected year is within the available range
    if year < 1987 or year > 2015:
        print(f"Data for the year {year} is not available.")
        return

    # Get the AQI data for the selected year
    year_data = yrst.loc[year - 1987]

    # Loop over states and plot AQI data on the map
    for idx, state in enumerate(stlist):
        aqi_value = year_data[state]

        if aqi_value > 0:  # Only display states with non-zero AQI values
            # Add a marker for each state with AQI value
            folium.CircleMarker(
                location=[latitudes[idx], longitudes[idx]],
                radius=8,
                color='red' if aqi_value > 150 else 'orange' if aqi_value > 100 else 'green',
                fill=True,
                fill_color='red' if aqi_value > 150 else 'orange' if aqi_value > 100 else 'green',
                fill_opacity=0.7,
                popup=f'{state}: {aqi_value}'
            ).add_to(m)

    # Display the map
    display(m)

def get_year_input():
    """
    Function to get the year input from the user and display the AQI hotspots.
    """
    try:
        year = int(input("Enter a year (1987-2015): "))
        display_hotspot_map(year)
    except ValueError:
        print("Invalid input. Please enter a valid year (1987-2015).1")

# Call the function to get user input
get_year_input()